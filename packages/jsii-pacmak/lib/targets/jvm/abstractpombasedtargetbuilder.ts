import path = require('path');
import fs = require('fs-extra');
import xmlbuilder = require('xmlbuilder');
import logging = require('../../logging');
import { VERSION_DESC } from '../../version';
import { Target } from '../../target';
import { TargetBuilder, BuildOptions, allOutputDirectoriesTheSame, OneByOneBuilder } from '../../builder';
import { JsiiModule } from '../../packaging';
import { Scratch } from '../../util';
import { TargetConstructor } from '../../target';

/**
 * Build Maven-based packages in parallel, by generating an aggregate POM
 */
export abstract class AbstractPomBasedTargetBuilder implements TargetBuilder {
  abstract targetName: string;
  abstract targetConstructor: TargetConstructor;

  abstract makeTarget(module: JsiiModule, options: BuildOptions): Target;

  public async buildModules(modules: JsiiModule[], options: BuildOptions): Promise<void> {
    if (modules.length === 0) { return; }

    // We can only do the optimized build if '-o' was specified, which we will notice
    // as all module outputdirectories being the same. (Maybe we can build to per-package
    // dist dirs as well, but this is the smallest delta from what we had and we will
    // always specify the output dir anyway).
    if (!allOutputDirectoriesTheSame(modules)) {
      logging.warn('Single output directory not specified, doing (slower) one-by-one build for Java');
      await new OneByOneBuilder(this.targetName, this.targetConstructor).buildModules(modules, options);
      return;
    }

    const singleOutputDir = this.finalOutputDir(modules[0], options);

    const moduleDirectories = [];

    for (const module of modules) {
      moduleDirectories.push(await this.generateModuleCode(module, options, options.codeOnly));
    }

    if (!options.codeOnly && modules.length > 0) {
      // Need a module to get a target
      const pomDirectory = await this.generateAggregatePom(moduleDirectories);
      const target = this.makeTarget(modules[0], options);

      await target.build(pomDirectory, singleOutputDir);
    }
  }

  private async generateModuleCode(module: JsiiModule, options: BuildOptions, finalDirectory?: boolean): Promise<Scratch<void>> {
    const target = this.makeTarget(module, options);

    const srcDir = finalDirectory
      ? Scratch.fake(this.finalOutputDir(module, options), undefined)
      : await Scratch.make(_ => undefined);

    logging.debug(`Generating ${this.targetName} code into ${srcDir.directory}`);
    await target.generateCode(srcDir.directory, module.tarball);

    return srcDir;
  }

  private async generateAggregatePom(sourceDirectories: Array<Scratch<void>>) {
    const parentDir = this.findSharedParentDirectory(sourceDirectories.map(s => s.directory));

    const aggregatePom = xmlbuilder.create({
      project: {
        '@xmlns': 'http://maven.apache.org/POM/4.0.0',
        '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
        '@xsi:schemaLocation': 'http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd',
        '#comment': [
          `Generated by jsii-pacmak@${VERSION_DESC} on ${new Date().toISOString()}`,
        ],

        'modelVersion': '4.0.0',
        'packaging': 'pom',

        'groupId': 'software.amazon.jsii',
        'artifactId': 'aggregatepom',
        'version': '1.0.0',

        'modules': {
          module: sourceDirectories.map(s => path.relative(parentDir, s.directory))
        }
      }
    }, { encoding: 'UTF-8' }).end({ pretty: true });

    logging.debug(`Generated ${parentDir}/pom.xml`);
    await fs.writeFile(path.join(parentDir, 'pom.xml'), aggregatePom);
    return parentDir;
  }

  /**
   * Find the longest shared given a set of directories
   */
  private findSharedParentDirectory(dirs: string[]) {
    if (dirs.length === 0) { return ''; }
    const dirParts = dirs.map(dir => dir.split(path.sep));

    return dirParts.reduce(longestPrefix).join(path.sep);

    function longestPrefix(accumulator: string[], current: string[]) {
      const len = Math.min(accumulator.length, current.length);
      let i = 0;
      while (i < len && accumulator[i] === current[i]) {
        i++;
      }
      return accumulator.slice(0, i);
    }
  }

  private finalOutputDir(module: JsiiModule, options: BuildOptions): string {
    if (options.languageSubdirectory) {
      return path.join(module.outputDirectory, this.targetName);
    }
    return module.outputDirectory;
  }
}